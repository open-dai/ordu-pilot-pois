package com.sampas.socbs.core.network.impl;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import com.sampas.socbs.core.network.IEdge;
import com.sampas.socbs.core.network.INode;
/**
 * Basic implementation of Node. 
 *
 * @author Justin Deoliveira, Refractions Research Inc, jdeolive@refractions.net
 *
 * @source $URL: http://svn.geotools.org/tags/2.4.4/modules/extension/graph/src/main/java/org/geotools/graph/structure/basic/BasicNode.java $
 */
public class SmpBasicNode extends SmpBasicGraphable implements INode {
  
  /** List of edges incident with the node. */
  transient private ArrayList m_edges;
  
  /**
   * Constructs a BasicNode.
   *
   */
  public SmpBasicNode() {
    super();
    m_edges = new ArrayList();
  }

  /**
   * Adds an edge to the adjacency list of the node which is an underlying List 
   * implementation. No checking is done on the edge (duplication, looping...), 
   * it is simply added to the list.
   *  
   * @see INode#add(IEdge)
   */
  public void add(IEdge e) {
    m_edges.add(e);  
  }
  
  /**
   * @see INode#remove(IEdge)
   */
  public void remove(IEdge e) {
    m_edges.remove(e);  
  }
  
  /**
   * @see INode#getDegree()
   */
  public int getDegree() {
    //since edges that loop on a node add 2 to the degree
    // of the node, the degree is not simply the size of the edge
    // list
    int degree = 0;
    
    for (int i = 0; i < m_edges.size(); i++) {
      IEdge e = (IEdge)m_edges.get(i);
      if (e.getNodeA().equals(this)) degree++;
      if (e.getNodeB().equals(this)) degree++;  
    }
    
    return(degree);
  }

  /**
   * @see INode#getEdge(INode)
   */
  public IEdge getEdge(INode other) {
    //must explictley check that the edge has node other, and one node this, 
    // just checking other is not good enough because of loops
    for (int i = 0; i < m_edges.size(); i++) {
      IEdge e = (IEdge)m_edges.get(i);
       if (
        (e.getNodeA().equals(this) && e.getNodeB().equals(other)) ||
        (e.getNodeA().equals(other) && e.getNodeB().equals(this))
      ) return(e);
    }
    return(null);
  }
  
  /**
   * @see INode#getEdges(INode)
   */
  public List getEdges(INode other) {
    //must explictley check that the edge has node other, and one node this, 
    // just checking other is not good enough because of loops
    ArrayList edges = new ArrayList();  
     for (int i = 0; i < m_edges.size(); i++) {
      IEdge e = (IEdge)m_edges.get(i);
      if (
        (e.getNodeA().equals(this) && e.getNodeB().equals(other)) ||
        (e.getNodeA().equals(other) && e.getNodeB().equals(this))
      ) edges.add(e); 
    }
    return(edges);
  }
  
  /**
   * @see INode#getEdges()
   */
  public List getEdges() {
    return(m_edges);  
  }
  
  /** 
   * Returns all nodes that are incident with adjacent edges minus itself. This
   * iterator is generated by calculating an underlying collection upon each 
   * method call. 
   * 
   * @see org.geotools.graph.structure.Graphable#getRelated()
   */
  public Iterator getRelated() {
    ArrayList related = new ArrayList(m_edges.size());
    for (int i = 0; i < m_edges.size(); i++) {
      IEdge e = (IEdge)m_edges.get(i);
      related.add(e.getOtherNode(this));
    }
    return(related.iterator());
  }
  
  /**
   * Overides the default deserialization operation. The edge adjacency list
   * of a BasicNode is not written out when the node is serialized so it must
   * be recreated upon deserialization.
   * 
   * @param in Object input stream containing serialized object.
   *
   * @throws IOException
   * @throws ClassNotFoundException
   */
  private void readObject(ObjectInputStream in)
   throws IOException, ClassNotFoundException {
     
    in.defaultReadObject();
    
    //recreate edge adjacency list
    m_edges = new ArrayList();
  }
  
}
